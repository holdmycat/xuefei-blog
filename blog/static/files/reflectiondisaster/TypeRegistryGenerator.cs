//------------------------------------------------------------
// File: TypeRegistryGenerator.cs
// Purpose: Build-time generator for BSON type registry to remove runtime reflection.
//------------------------------------------------------------
#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Ebonor.Framework;
using UnityEditor;
using UnityEditor.Build;
using UnityEditor.Build.Reporting;
using UnityEngine;

namespace Ebonor.DataCtrl
{
    /// <summary>Generates a static type registry used at runtime to avoid Assembly scanning.</summary>
    public class TypeRegistryGenerator : IPreprocessBuildWithReport
    {
        public int callbackOrder => 0;

        private const string OutputPath = "Assets/Scripts/DataCtrl/Generated/GeneratedTypeRegistry.cs";

        [MenuItem("Custom Windows/Generate/Type Registry")]
        public static void GenerateFromMenu() => Generate();

        public void OnPreprocessBuild(BuildReport report) => Generate();

        private static void Generate()
        {
            try
            {
                var unityObjectTypes = GetUnityObjectTypes();
                var (bsonParentTypes, bsonChildTypes) = GetBsonAttributeTypes(unityObjectTypes);

                var code = BuildCode(unityObjectTypes, bsonParentTypes, bsonChildTypes);
                WriteFile(OutputPath, code);
                Debug.Log($"[TypeRegistryGenerator] Generated {OutputPath} with {unityObjectTypes.Count} UnityEngine.Object types.");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[TypeRegistryGenerator] Generation failed: {ex}");
                throw;
            }
        }

        private static List<Type> GetUnityObjectTypes()
        {
            var targetAssemblies = AppDomain.CurrentDomain.GetAssemblies()
                .Where(IsTargetAssembly)
                .ToHashSet();

            return UnityEditor.TypeCache.GetTypesDerivedFrom<UnityEngine.Object>()
                .Where(t => !t.IsAbstract && !t.IsGenericType && targetAssemblies.Contains(t.Assembly))
                .OrderBy(t => t.FullName, StringComparer.Ordinal)
                .ToList();
        }

        private static (List<Type> parents, List<Type> children) GetBsonAttributeTypes(IEnumerable<Type> sourceTypes)
        {
            var parents = new List<Type>();
            var children = new List<Type>();

            foreach (var type in sourceTypes)
            {
                if (type.GetCustomAttributes(typeof(Ebonor.DataCtrl.BsonDeserializerRegisterAttribute), false).Length > 0)
                {
                    parents.Add(type);
                }

                if (type.GetCustomAttributes(typeof(Ebonor.DataCtrl.BsonDeserializerRegisterAttribute), true).Length > 0)
                {
                    children.Add(type);
                }
            }

            return (parents, children);
        }

        private static bool IsTargetAssembly(System.Reflection.Assembly asm)
        {
            var name = asm.FullName;
            return name.Contains(ConstData.AD_DATACTRL)
                   || name.Contains(ConstData.AD_MULTIPLAYER);
                    //|| name.Contains(ConstData.AD_MANAGER);
        }

        private static string BuildCode(
            List<Type> unityObjectTypes,
            List<Type> parentTypes,
            List<Type> childTypes)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("// Generated by TypeRegistryGenerator. Do not edit manually.");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine("using System;");
            sb.AppendLine("using MongoDB.Bson.Serialization;");
            sb.AppendLine("using UnityEngine;");
            sb.AppendLine("namespace Ebonor.DataCtrl");
            sb.AppendLine("{");
            sb.AppendLine("    public static class GeneratedTypeRegistry");
            sb.AppendLine("    {");

            AppendTypeArray(sb, "UnityObjectTypes", unityObjectTypes);
            AppendTypeArray(sb, "BsonParentTypes", parentTypes);
            AppendTypeArray(sb, "BsonChildTypes", childTypes);

            sb.AppendLine("        public static void RegisterAllBsonClassMaps()");
            sb.AppendLine("        {");
            sb.AppendLine("            foreach (var type in UnityObjectTypes)");
            sb.AppendLine("            {");
            sb.AppendLine("                if (type == null || type.IsGenericType) continue;");
            sb.AppendLine("                if (!BsonClassMap.IsClassMapRegistered(type))");
            sb.AppendLine("                    BsonClassMap.LookupClassMap(type);");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            foreach (var child in BsonChildTypes)");
            sb.AppendLine("            {");
            sb.AppendLine("                foreach (var parent in BsonParentTypes)");
            sb.AppendLine("                {");
            sb.AppendLine("                    if (parent != null && parent.IsAssignableFrom(child) && parent != child)");
            sb.AppendLine("                    {");
            sb.AppendLine("                        if (!BsonClassMap.IsClassMapRegistered(child))");
            sb.AppendLine("                            BsonClassMap.LookupClassMap(child);");
            sb.AppendLine("                    }");
            sb.AppendLine("                }");
            sb.AppendLine("            }");
            sb.AppendLine("        }");

            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }

        private static void AppendTypeArray(StringBuilder sb, string name, List<Type> types)
        {
            sb.AppendLine($"        public static readonly Type[] {name} = new Type[]");
            sb.AppendLine("        {");
            for (int i = 0; i < types.Count; i++)
            {
                sb.Append("            typeof(")
                  .Append(types[i].FullName)
                  .Append(")");
                if (i < types.Count - 1) sb.Append(",");
                sb.AppendLine();
            }
            sb.AppendLine("        };");
            sb.AppendLine();
        }

        private static void WriteFile(string path, string contents)
        {
            var dir = Path.GetDirectoryName(path);
            if (!Directory.Exists(dir))
            {
                Directory.CreateDirectory(dir);
            }

            File.WriteAllText(path, contents, Encoding.UTF8);
            AssetDatabase.ImportAsset(path);
        }
    }
}
#endif
