---
title: "Optimization of Combat Unit ID Generation Strategy"
date: 2025-12-26T09:17:00+08:00
draft: false
tags: ["Architecture", "Network", "Optimization"]
---

# Optimization of Combat Unit ID Generation Strategy

This document analyzes the refactoring of the ID generation mechanism for combat units in the `Modular-Skill-System-Demo` project, comparing the pros and cons of the Hash-based deterministic scheme versus the atomic auto-increment scheme, and clarifying relevant technical concepts.

## 1. Background

- **Game Type**: SLG Combat Simulation (Simulation Game Logic).
- **Network Architecture**: Server Authority. All combat logic calculations, unit spawning, and destruction are solely handled by the server; the client is responsible for presentation only.
- **ID Structure**: As a hierarchical combat system, our ID structure is composite: `LegionId = (CommanderNetId << 32) | LocalIndex`.

## 2. Problem Analysis: Over-engineering

**Previous Scheme**:
The initial design used a **Hash Generation Strategy** based on configuration data (Seed).

- Logic: `Hash(ScenarioId + Faction + Slot + ...) = CommanderNetId`.
- Purpose: Attempted to generate identical IDs from identical configurations (i.e., "Configuration Idempotency") even without central server coordination.

**Issues Identified**:

1. **Complexity**: Introduced string concatenation, hash calculation, and collision detection logic, resulting in high maintenance costs.
2. **Unnecessary**: Under Server Authority architecture, IDs are **assigned** by the server, not **calculated** by clients. Clients do not need to predict IDs; they only need to accept `RPC` notifications.
3. **Collision Risk**: Although extremely low, hash algorithms theoretically always carry a risk of collision. In the `uint` range, atomic auto-increment is absolutely collision-free.

## 3. Comparison

| Feature | Old Scheme: Deterministic Hash | New Scheme: Atomic Auto-Increment |
| :--- | :--- | :--- |
| **Source** | Static Configuration Data (Seed) | Runtime Global Counter (Global Counter) |
| **Uniqueness** | Probabilistic (Tiny collision risk) | **Absolute** (Until overflow) |
| **Complexity** | High (Serialization, Hash calculation) | **Extremely Low** (`Interlocked.Increment`) |
| **Readability** | Poor (e.g., `2938481`) | **Excellent** (e.g., `1, 2, 3...`) |
| **Scenario** | Lockstep, P2P, Offline Calculation | **State Sync**, CS Architecture |

## 4. Conflict Analysis

The new scheme uses `Interlocked.Increment` to generate `CommanderNetId`.

**Why no conflicts?**
Our `LegionId` is a 64-bit composite ID:

```csharp
ulong LegionId = ((ulong)CommanderNetId << 32) | LocalSquadIndex;
```

1. **High 32 Bits (CommanderNetId)**:
    Generated by a server-global, static counter. Every newly created Commander receives a unique ID (e.g., 10, 11, 12...). Thus, the ID space between different Commanders is physically isolated.

2. **Low 32 Bits (LocalSquadIndex)**:
    Generated by a counter maintained internally within each Commander instance. As long as a single Commander does not generate more than 4.2 billion ($2^{32}$) units, the low bits will not overflow.

**Conclusion**: As long as `CommanderNetId` is non-repeating, the combined `LegionId` is mathematically globally unique.

## 5. Concepts Definition

In discussing the choice of schemes, we touched upon two concepts that the old scheme tried to support but are unnecessary for this project:

### A. Stateless Reconnection

- **Definition**: When a client reconnects after disconnection, the server does not need to retain the player's previous session state or go through complex handshake procedures to restore context. The client relies solely on the current full Snapshot sent by the server to rebuild the game world.
- **Relation to ID**: In stateless reconnection, when the client rebuilds the world, it receives the IDs currently in the server's memory. Therefore, regardless of how the Server ID was generated (Auto-increment or Hash), as long as the snapshot contains this ID, the client can display it correctly. This further corroborates that clients do not need to predict IDs.

### B. Configuration Idempotency

- **Definition**: Idempotency means "the same input always produces the same output." Here it refers to: as long as the given combat configuration (Seed) is unchanged, the generated unit IDs are completely fixed regardless of when, where, or in what order the game is started.
- **Applicability**: This is critical in **Lockstep** games or **Replay-based Validation Systems**, where each client must independently calculate completely consistent states. However, for **Server Authority State Sync** games, the ID is merely a runtime reference handle, and its actual numerical value does not affect logical correctness, so strict idempotency is not required.
